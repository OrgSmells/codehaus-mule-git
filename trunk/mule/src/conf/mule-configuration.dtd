<!--
	Mule - Universal Message Objects <font size="-2">(TM)</font>
	This DTD describes the grammar of the mule configuration properties
	<p>
	Author: Ross Mason, Cubis Limited &#169; 2003-2005
	</p>
	The mule is the root element of a <i>mule-config.xml</i> file.
	It consists of one connection-descriptor and at least one
	mule-model element.
	@root mule-configuration

-->

<!ELEMENT mule-configuration ((mule-environment-properties)?,(environment-properties)?, (security-manager)?, (transaction-manager)?,
            (agents)?,(connector)*,(endpoint-identifiers)?,(transformers)?,(global-endpoints)?,
		    (interceptor-stack)*,(container-context)?,(model)+,(mule-descriptor)*)>

<!--
    The id attribute allows for a unique id for this file as it is often the case that
    distributed Mule environments have their own properties
-->   	
<!ATTLIST mule-configuration id		  	NMTOKEN         #IMPLIED>
<!--
	The version attribute is used to bind a mule_props.xml
    file to a given version of this dtd. This will help to
    avoid versions conflicts.
-->
<!ATTLIST mule-configuration version    (1.0)           #REQUIRED>

<!--
	<i>mule-environment-params</i> are prarameters used by the Mule run-time. If none or not all
	parameters are specified defaults will be used
-->
<!ELEMENT mule-environment-properties ((threading-profile)*, (pooling-profile)?, (queue-profile)?)>

<!--
	Specifies whether mule should process messages sysnchonously, i.e. that a mule-model
	can only processone message at a time, or asynchonously.  The default value is
	'false'.
-->

<!ATTLIST mule-environment-properties synchronous     				(true | false)          "false">
<!--
	A property file can specify more than one mule-model.  In the situation when more than
	one is difined this property tells Mule which model to load.  If this is not specifed
	the first model is used.
	<strong>This property currently is not used</strong>
-->
<!ATTLIST mule-environment-properties model							IDREF					#IMPLIED>

<!--
     The directory where mule can write any temporary files or persist messages
-->
<!ATTLIST mule-environment-properties workingDirectory  		CDATA                 "./.mule">

<!--
     When running sychonously, return events can be received over transports that support ack or replyTo
     This property determines how long to wait for a receive
-->
<!ATTLIST mule-environment-properties synchronousEventTimeout  		NMTOKEN                 #IMPLIED>

<!--
     Default transaction timeout
-->
<!ATTLIST mule-environment-properties transactionTimeout  		NMTOKEN                 #IMPLIED>

<!--
     Determines whether when running synchronously, return events are received before
     returning the call. i.e. in jms wait for a replyTo. Vm queues do this automatically
-->
<!ATTLIST mule-environment-properties synchronousReceive  		(true | false)          "false">

<!--
     Is the default endpointUri where Mule can receive Action requests such as running a
     send, dispatch or receive request from a remote client. If not specified the default will
     be used of tcp://localhost:60504.
     Note users can explicitly configure the MuleManagerComponent that serves these type of
     requests and this variable need not be set.
-->
<!ATTLIST mule-environment-properties serverUrl  		            NMTOKEN          #IMPLIED>

<!--
     Determines whether Mule's internal queues are persisted.  If the server dies unexpectedly Mule
     can resume processing when the server starts
-->
<!ATTLIST mule-environment-properties recoverableMode   		(true | false)          "false">

<!--
A pooling profile is used to configure the pooling behaviour of UMO components.
each descriptor can set it's own pooling profile or a default one can be set
on the mule-configuration.
-->

<!ELEMENT pooling-profile EMPTY>

<!--
    Controls the maximum number of Mule UMOs that can be borrowed from a Session at one time.
    When non-positive, there is no limit to the number of components that may be active at one time.
    When maxActive is exceeded, the pool is said to be exhausted.
    You can specify this value on the descriptor declaration. If none is set this value
    will be used.
-->
<!ATTLIST pooling-profile maxActive        		NMTOKEN         		#IMPLIED>

<!--
	Controls the maximum number of Mule UMOs that can sit idle in the pool at any time. When non-positive,
	there is no limit to the number of Mule UMOs that may be idle at one time.
	You can specify this value on the descriptor declaration. If none is set this value
    will be used.
-->

<!ATTLIST pooling-profile maxIdle          		NMTOKEN         		#IMPLIED>
<!--
    Determines how components in a pool should be initialised. the possible values are -
    <ul>
        <li>INITIALISE_NONE : Will not load any components in the pool on startup</li>
        <li>INITIALISE_FIRST : Will load only the first component in the pool on startup</li>
        <li>INITIALISE_ALL : Will load all components in the pool on startup</li>
    </ul>
   The default for this value is INITIALISE_FIRST.

-->
<!ATTLIST pooling-profile initialisationPolicy  		(INITIALISE_NONE | INITIALISE_FIRST | INITIALISE_ALL)		"INITIALISE_FIRST">
<!--
     Specifies the behaviour of the Mule UMO pool when the pool is exhausted:
      <p/>
      0 (WHEN_EXHAUSTED_FAIL) : will throw a NoSuchElementException
      1 (WHEN_EXHAUSTED_BLOCK): will block (invoke Object.wait(long) until a new or idle object is available.
      2 (WHEN_EXHAUSTED_GROW) : will create a new Mule and return it(essentially making maxActive meaningless.)
     <p/>
     If a positive maxWait value is supplied, it will block for at most that many milliseconds,
     after which a NoSuchElementException will be thrown. If maxThraedWait is non-positive, it will block
     indefinitely.
-->
<!ATTLIST pooling-profile exhaustedAction  		(GROW | WAIT | FAIL)      "GROW">
<!--
Specifies the number of milliseconds to wait for a pooled component to become available
when the pool is exhausted and the exhaustedAction is set to 'wait'.
-->
<!ATTLIST pooling-profile maxWait  		NMTOKEN					#IMPLIED>

<!--
A fully qualified classname of the pool factory to use with this pool profile.
Implementations must implement org.mule.umo.UMOPoolFactory.
-->
<!ATTLIST pooling-profile factory  		NMTOKEN					"org.mule.config.pool.CommonsPoolFactory">



<!ELEMENT threading-profile EMPTY>

<!-- The threading profile system id.  This is used to identify which system
component should use the profile. This attribute is only used when declaring profiles on
the mule-evironment-properties element and on connector components where 'messageReciever'
or 'messageSender' can be used. For all other cases it can be set to 'default'.
-->
<!ATTLIST threading-profile id  (receiver|dispatcher|component|default)  "default">

<!--
    Controls the maximum number of threads that can be executed at any one time in a thread
    pool
-->
<!ATTLIST threading-profile maxThreadsActive        		NMTOKEN         		#IMPLIED>

<!--
	Controls the maximum number threads that can be inactive or idle in a thread pool before they
    are destroyed.
-->

<!ATTLIST threading-profile maxThreadsIdle          		NMTOKEN         		#IMPLIED>
<!--
	Detemines how long an inactive thread is kept in the pool before being discarded
-->
<!ATTLIST threading-profile threadTTL           		NMTOKEN         		#IMPLIED>
<!--
If the maximum pool size or queue size is bounded, then it is possible for incoming execute requests to block.
There are five supported policies for handling this situation.

<ol>
<li>RUN (the default) - The thread making the execute request runs the task itself. This policy helps guard against lockup.
</li>
<li>WAIT - Wait until a thread becomes available. This policy should, in general, not be used if the minimum number of of threads is zero, in which case a thread may never become available.
</li>
<li>ABORT - Throw a RuntimeException
</li>
<li>DISCARD  - Throw away the current request and return.
</li>
<li>DISCARD_OLDEST - Throw away the oldest request and return.
</li></ol>
-->

<!ATTLIST threading-profile poolExhaustedAction 	(WAIT | DISCARD | DISCARD_OLDEST | ABORT | RUN)       "RUN">

<!--
determines whether threading is enabled for a connector.  It's useful to set this to false
when testing.  Setting it on the defaultThreadingProfile on the Mule configuration will disable
threading in every connector
-->
<!ATTLIST threading-profile doThreading 	(true | false)       "true">

<!--
    Determines how many requests if any are queue when the pool is at maximum
    usage capacity.  The buffer is used as an overflow.
-->
<!ATTLIST threading-profile maxBufferSize   NMTOKEN         #IMPLIED>

<!--
    A Queue Profile is used to describe the the properties of an internal Mule queue. Internal queues are used to
    queue events for each component managed by Mule.
-->

<!ELEMENT queue-profile (persistence-strategy?,properties?)>

<!--
    Defines the maximum number of message that can be queued.
-->
<!ATTLIST queue-profile maxOutstandingMessages   NMTOKEN         #IMPLIED>

<!--
    The number of milliseconds to wait if the queue has reached max capacity
    before trying to queue more events
-->
<!ATTLIST queue-profile blockWait   NMTOKEN         #IMPLIED>

<!--
   A persistence strategy defines the mechanism used to store Mule events to a persistent store.  Primarily, this
   is used for for persisting queued events to disk so that the servers internal state is mirrored on disk in case
   the server fails and needs to be restarted.  
-->
<!ELEMENT persistence-strategy (properties?)>

<!-- 
    A fully qualified class name of the org.mule.util.queue.PersistenceStrategy implementation to use to store
    mule events.
-->
<!ATTLIST persistence-strategy className   NMTOKEN         #REQUIRED>

<!--
    The environment-param element allows to add custom properties.  These are accessible
    from the MuleManager getProperty method
  -->
<!ELEMENT environment-properties ((property | factory-property | system-property | map | list)+)>

<!--
	This element specifies the transaction manager to use (if any) in the Mule Server
	The configuration must specify a factory attribute which is a fully qualified class
	name of a Transaction factory that implements org.mule.umo.UMOTransactionManagerFactory

  -->
<!ELEMENT transaction-manager (properties?)>

<!--
	The <i>factory</i> specifies the transaction manager factory to use to
	create a transaction manager for the Mule server

	The <i>property</i> element allows to add custom attributes.  Each of the
	key value pair attributes will be passed to the connection as a HashMap
	The connection implementation will then handle how these properties are set.
-->

<!ATTLIST transaction-manager factory        		NMTOKEN         		#REQUIRED>

<!--
	This element specifies the security manager to use (if any) for this Mule Server instance
	The security manager is responsible for managing one or more security providers that can
    validate user credentials

  -->
<!ELEMENT security-manager (security-provider*, encryption-strategy*)>

<!--
	The <i>className</i> is optional and specifies the security manager to use.
-->

<!ATTLIST security-manager className        		NMTOKEN         		#IMPLIED>

<!--
   A security provider allows credentials to be authenticated against various credential
   providers.
-->
<!ELEMENT security-provider (properties?)>

<!--
 A fully qualified class name of the security provider to use
 -->
<!ATTLIST security-provider className        		NMTOKEN         		#REQUIRED>

<!--
 A unique name that identifies the security provider
 -->
<!ATTLIST security-provider name        		ID         		#REQUIRED>

<!--
   A encryption strategy is a encryption configuration object that
   can be used by mule components to perform en/decryption.  The main
   components that will use these strategies are security filters and
   transformers
-->
<!ELEMENT encryption-strategy (properties?)>

<!--
 A fully qualified class name of the encryption strategy to use
 -->
<!ATTLIST encryption-strategy className        		NMTOKEN         		#REQUIRED>

<!--
 A unique name that identifies the encryption strategy
 -->
<!ATTLIST encryption-strategy name        		ID         		#REQUIRED>

<!--
The <i>connection-descriptor</i> element specifies one or more message
  connections for Mule components.
-->
  
<!ELEMENT connector (properties?, threading-profile?, exception-strategy?)>

<!--
	The name attribute is used to bind a connection to a logical name in the system
	This must be unique for each Mule instance
-->

<!ATTLIST connector name 				ID		#REQUIRED>
<!--
	The fully qualified classname to instanciate the connector with  
-->
<!ATTLIST connector className			NMTOKEN		#REQUIRED>

<!--
	This is a grouping element for individual <i>endpoint-identifier</i> instances
-->

<!ELEMENT endpoint-identifiers (endpoint-identifier+)>

<!--
	A <i>endpoint-identifier</i> is a mapping between an endpoint and a logical name.  The MuleManager
	provides an interface to lookup these endpoints. Essentially this is just a key value
	pair i.e.  you may map -
	<ul>
		<li>Fault Email -&gt; smtp://admin&#64;mycompany.com</li>
		<li>Shipping Manager  -&gt; jms://shipping.orders.topic</li>
		<li>Administrators Mobile -&gt; sms://+447910010010</li>
	</ul>
-->

<!ELEMENT endpoint-identifier EMPTY>

<!--
	name
	The logical endpoint name
-->
<!ATTLIST endpoint-identifier name 		CDATA			#REQUIRED>
<!--
	value
	The corresponding endpoint value
-->
<!ATTLIST endpoint-identifier value		CDATA			#REQUIRED>

<!--
	A grouping element for all transformer declarations
-->
<!ELEMENT transformers (transformer+)>

<!--
	Transformers are used to convert objects from one type to another.  mule-descriptors
	can be associated with two transformers: one for inbound messages and one of
	outbound messages.
	All transformers must implement <i>org.mule.transformers.Transformer</i>

    	The <i>org.mule.doCompression</i> property determines whether a transformer should 
    	compress/uncompress its data.  This attribute is ignored unless the 
    	transformer named in the className attribute extends 
    	<i>org.mule.transformers.compression.AbstractCompressionTransformer</i>
    	This is a fairlycommon property but must be specified on the transformer
    	declaration as a property i.e.
    	
    	<code>
    	&lt;transformer name="ObjectToJMSMessage" className="org.mule.transformers.ObjectToJMSMessage" returnClass="javax.jms.BytesMessage"&gt;
			&lt;properties&gt;
				&lt;property name="org.mule.doCompression" value="true"/&gt;
			&lt;/properties&gt;
		&lt;/transformer&gt;
		</code>
-->

<!ELEMENT transformer (properties?)>

<!--
    	name
    	The logical name for the transformer.  When the transformer is 
    	registered it's name will be used to reference the transformer.
    	If this attibute is not set then it will default to it's class 
    	name without the pakage prefix.   
-->
<!ATTLIST transformer name	                  ID    			#IMPLIED>
<!--
    The className attribute represents the full qualified class name
    of the Transformer implementation 
 -->
<!ATTLIST transformer className               NMTOKEN 			#REQUIRED>

<!--
    	The returnClass attribute represents the full qualified class name
    	of the expected return Object of the Transformer implementation. if none is
    	specified java.lang.Object is used by default. However, by suppling a returnClass
    	the transformer can validate that the returnObject is of expected type before return
    	to the callee.
-->
<!ATTLIST transformer returnClass             NMTOKEN 			"java.lang.Object">

<!--	
	<i>global-endpoints</i> are endpoint configurations made available to all components in
	a model through the MuleManager. This is a grouping element for individual 
	<i>endpoint</i> instances
	
-->
<!ELEMENT global-endpoints (endpoint+)>

<!--

	A <i>endpoint</i> are communication channel definitions to some message system.  These
	are used to publish and subscibe messages in and outside of Mule

    If the endpoint is of type receiver The filter is used to filter incoming
    events.  Not all endpoint providers support filtering so if a filter is set on an endpoint
    that uses a provider that doesn't support filtering an UnsupportedOperationException
    is thrown.

	The property element allows to add custom attributes to the endpoint.

-->

<!ELEMENT endpoint ((transaction)?, (filter)?, (security-filter)?, (properties)?)>

<!--
	The name attribute is used to bind a <i>endpoint</i> to a logical name in the system
	This must be unique for each Mule instance. If not set one will be generated
-->

<!ATTLIST endpoint name 		ID    		#IMPLIED>
<!--
	This specifes the communication endpoint.  This will have a different format depending
	on the transport protocol being used i.e.
	<ul>
		<li>smtp -&gt; admin&#64;mycompany.com</li>
		<li>jms  -&gt; shipping.orders.topic</li>
		<li>sms  -&gt; +447910010010</li>
	</ul>

	if an endpoint address is not specifed it will be assumed that it will be determined at run-time
	by the calling application.  The endpoint address must be a URI address or it can be a logical name for an
    endpoint as long as it is declared in a <i>endpoint</i> block.
	Example uris are:
	<ul>
		<li>vm://localhost/test.queue?transformers=ObjectToXml</li>
		<li>pop3://ross:password@mail.muleumo.org?createConnector=ALWAYS</li>
		<li>file:///C:/temp/mule?transformers=FileMessageToObject</li>
	</ul>
-->

<!ATTLIST endpoint address		CDATA			#REQUIRED>
<!--
	The name of connector to use for this endpoint.  The protocol of the connector
    named must match the protocol of the endpoint address.  If this value is not set
    the first connector found with the correct protocol will be used
-->
<!ATTLIST endpoint connector	IDREF   		#IMPLIED>
<!--
	Determines whether the endpoint provider is a sender, receiver or a senderAndReceiver.
    An endpoint can be senderAndReciever meaning that there is no difference for the endpoint
    configuration if it is used as a sender or receiver.

-->
<!ATTLIST endpoint type		(sender | receiver | senderAndReceiver) 	"senderAndReceiver">

<!--
    Is responsible for transforming data when it is received or sent by the UMO 
    (depending on whether this endpoint is a receiver or not). A tranformation for an
    inbound event can be forced by the user by calling the inbound event.getTransformedMessage().
    A tranformation for an outbound event is called or when the UMO dispatchEvent()
    or sendEvent() methods are called.
-->	
<!ATTLIST endpoint transformers	IDREFS			#IMPLIED>

<!--
    synchronous
    determines if requests received on this endpoint execute within a single thread
    if not set the MuleManager synchronous property will be used
-->
<!ATTLIST endpoint synchronous	(true|false)			#IMPLIED>

<!--
    A global endpoint reference
-->
<!ELEMENT global-endpoint (transaction?, filter?, security-filter?, properties*)>

<!--
    name
    The name of the global referene to use
-->
<!ATTLIST global-endpoint name	IDREF			#REQUIRED>

<!--
    address
    Used to override the address on the global endpoint
-->
<!ATTLIST global-endpoint address	CDATA			#IMPLIED>

<!--
    address
    Used to override the transformers on the global endpoint
-->
<!ATTLIST global-endpoint transformers	IDREFS			#IMPLIED>

<!--
    synchronous
    determines if requests received on this endpoint execute within a single thread
    if not set the MuleManager synchronous property will be used
-->
<!ATTLIST global-endpoint synchronous	(true|false)			#IMPLIED>

<!--
A security filter ensures that all requestsmade via an endpoint will be authenticated
-->
<!ELEMENT security-filter (properties?)>

<!--
By default, all providers registered with the security manager will be
authenticated against.  However a space separated list of provider names can
be specified to change the order or the restrict the list of security
providers used.
-->
<!ATTLIST security-filter useProviders	IDREFS			#IMPLIED>

<!--
A fully qualified classname of the security filter to use on this endpoint
-->
<!ATTLIST security-filter className	NMTOKEN			#REQUIRED>

<!--
	Defines transacitonal behaviour for this endpoint
-->

<!ELEMENT transaction (constraint?)>

<!--
	The factory attribute defines the <i>UMOTransactionFactory</i> to use when creating new
	transactions. This is only require when the transaction config is declared on an inbound
    provider.
-->

<!ATTLIST transaction factory 		NMTOKEN    		#IMPLIED>

<!--
	The beginAction attribute determise the way that the provider demarcates 
	transactions when it receives an event.
	
	NONE - tells the provider not to do anything regarding transaction management.
	ALWAYS_BEGIN - Will always start a new transaction when an event is received.
	BEGIN_OR_JOIN - Will join the transaction if one is in progress otherwise one will be started.
	ALWAYS_JOIN - Expects a transaction to be in progress and joins it.
	JOIN_IF_POSSIBLE - Will join a transaction if one is in progress others just continues processing.
	
-->

<!ATTLIST transaction beginAction 		(NONE | ALWAYS_BEGIN |
										BEGIN_OR_JOIN | ALWAYS_JOIN |
										JOIN_IF_POSSIBLE )     			#IMPLIED>

<!--
	The commitAction attribute determines how transactions are managed when an event is published.
	
	NONE - tells the provider not to do anything regarding transaction management.
	ALWAYS_COMMIT - Will expect a transaction to be in process and will commit it.
	JOIN_IF_POSSIBLE - Will commit a transaction if one is in progress others just continues processing.
	
-->

<!--<!ATTLIST transaction commitAction 		(NONE | ALWAYS_COMMIT | COMMIT_IF_POSSIBLE )    		#IMPLIED>-->

<!--
	Transaction timeout for transactions initiated from the endpoint associated with
    this transaction config.
-->

<!ATTLIST transaction timeout 		NMTOKEN    		#IMPLIED>

<!--
    Constraints can be defined on a send provider to control how and when a transaction
    gets committed.  For example, to commit a transaction once 3 jms messages have been
    processed you can define a BatchConstraint on the transaction and set the batch size to 3.
    These constraints work the same way as filters and properties on the filters can be set
    as attributes on the filter xml element.
-->
<!ELEMENT constraint (left-filter?,right-filter?, filter?)>

<!--
    className
    A fully qualified class name of the filter Constraint to use.  Implementations should always
    implement <i>org.mule.umo.UMOFilter</i>.
-->
<!ATTLIST constraint className          NMTOKEN         #REQUIRED>

<!-- 
because I can't find a way of allowing arbitary attributes on an element, 
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser.
-->
<!ATTLIST constraint batchSize                 NMTOKEN         #IMPLIED>
<!ATTLIST constraint frequency                 CDATA           #IMPLIED> <!-- milliseconds -->
<!ATTLIST constraint expectedType              CDATA           #IMPLIED>
<!ATTLIST constraint path                      CDATA           #IMPLIED>
<!ATTLIST constraint pattern                   CDATA           #IMPLIED>
<!ATTLIST constraint expression                CDATA           #IMPLIED>


<!--
  Interceptors can be executed in sequence before and/or after the Mule component.
  A <i>interceptor-stack/i> is a stack of interceptors that can be assigned to multiple
  Mule components to provide standard functionality.
-->

<!ELEMENT interceptor-stack (interceptor+)>
<!--
	The idenfying name for the interceptor stack
-->

<!ATTLIST interceptor-stack name 			ID 		#REQUIRED>

<!--
Agents is a collection of one or more agent configurations
-->

<!ELEMENT agents (agent+)>

<!--
    An agent is a server plugin that can be initialised stated and destroyed along with the UMOManager itself.
    Agents can initialise or bind to external services such as Jmx server
-->
<!ELEMENT agent (properties?)>

<!--
    Unique name for the agent
-->
<!ATTLIST agent name 			CDATA 		#REQUIRED>

<!--
    The fully qualified classname of the Agent
-->
<!ATTLIST agent className 			NMTOKEN 		#REQUIRED>

<!--
	A Container context is used to retrieve object properties from the container.
    A container property is referenced using the container-property element.
    There are different implementations for different containers
	such as PicoContainer or Spring
-->
<!ELEMENT container-context (properties?)>

<!--

	The fully qualified class name of the container context.  Customer contexts must implement
	<i>org.mule.umo.UMOContainerContext</i>.
    Configuration of the container itself should be provided though properties on this
    element.
-->
<!ATTLIST container-context className  	NMTOKEN		#REQUIRED>

<!--
	The <i>model</i> defines the components and interations between components in the Mule
	run-time environment.  Here is specified which components exist in the system and how they
	should behave.
-->

<!ELEMENT model (description?,(entry-point-resolver)?, (component-lifecycle-adapter-factory)?, (component-pool-factory)?, (exception-strategy)?, (mule-descriptor)*)>

<!--	
	The name to associate this mule-model with
-->

<!ATTLIST model name  			ID		#REQUIRED>

<!--
	An entry Point resolver is used to determine which method on a UMO object
	should receive events
-->
<!ELEMENT entry-point-resolver EMPTY>

<!--
	The fully qualified class name of the resolver to use on this model
-->

<!ATTLIST entry-point-resolver className  		NMTOKEN		#REQUIRED>

<!--
	A Lifecycle adapter factory for creating a LifecycleAdapter for UMO componenets.
	This allows customer lifecycle event behaviour for UMO components.
-->
<!ELEMENT component-lifecycle-adapter-factory EMPTY>

<!--	
	The fully qualified class name of the lifecycle adapterfactory.  Custom lifecycle adapters
	must implement <i>org.mule.umo.lifecycle.UMOLifecycleAdapterFactory</i>
-->

<!ATTLIST component-lifecycle-adapter-factory className  		NMTOKEN		#REQUIRED>

<!--
	An component pool factory is used to determine what pool implementation should be used by mule to
    pool UMOComponent instances.  Mule ships with  Pico pool (picoContainer) and commons pool(jakarta)
    implementations
-->
<!ELEMENT component-pool-factory (properties?)>

<!--
	The fully qualified class name of the component pool factory to use on this model
-->

<!ATTLIST component-pool-factory className  		NMTOKEN		#REQUIRED>


<!--
	A <i>mule-descriptor</i> describes a single mule component, a MuleUMO. a component is an autonomous
	unit that executes a particular function by receiving an input doing some processing
	on the input and outputig a result, thus triggering futher events in the system.
-->

<!ELEMENT mule-descriptor ((inbound-router)?, (outbound-router)?, (response-router)?, (interceptor)*, (threading-profile)?, (pooling-profile)?, (queue-profile)?, (exception-strategy)?, (properties)?)>

<!--
	name
	The name to associate with the mule-descriptor
-->

<!ATTLIST mule-descriptor name 				    		CDATA   	    #REQUIRED>

<!--
	The transformer to use when receiving events on the specified inboundProvider. 
-->
<!ATTLIST mule-descriptor inboundTransformer			IDREFS	        #IMPLIED>
<!--
	The transformer to use when receiving events on the specified outboundProvider. 
-->
<!ATTLIST mule-descriptor outboundTransformer			IDREFS	        #IMPLIED>
<!--
	The class of the object or an object reference of the component being registered as an UMO. 
	If the implementation is an object reference then it will be resolved using the component resolver
	configured on the model
-->
<!ATTLIST mule-descriptor implementation		    	NMTOKEN         #REQUIRED>
<!--
	The default subject that the Mule UMO sends events.
-->
<!ATTLIST mule-descriptor inboundEndpoint		    	CDATA	        #IMPLIED>
<!--
	The default subject that the Mule UMO receive events.
-->
<!ATTLIST mule-descriptor outboundEndpoint					CDATA	        #IMPLIED>
<!--
    The version on the Mule UMO.  This is currently not used by the mule run-time but may
    be used in future
-->
<!ATTLIST mule-descriptor version                 		NMTOKEN         #IMPLIED>

<!--
    If an IoC container is being used this property can be set to determine if this component
    is constructed (and contained in) the container or is instanciated by Mule.
-->
<!ATTLIST mule-descriptor containerManaged			(true | false)			"true">

<!--
    A message router configures different routing paths for events that are dispatched for a UMO
    component. An outbound router is concerned with messages/events being sent out from a UMO component.
    You can specify diferent routing rules for different providers configured on the
    mule-descriptor.  You can also chain routers together by embedding one router declaration inside
    the other
-->
<!ELEMENT outbound-router (catch-all-strategy?, router+)>

<!--
Whether every configured router will be matched against
-->
<!ATTLIST outbound-router matchAll               (true | false)           "false">

<!--
   A message router configures different routing paths for events that are dispatched for a UMO
    component. An inbound router is concerned with messages/events being received by providers configured
    on the mule-descriptor.
-->
<!ELEMENT inbound-router ((catch-all-strategy)?,(endpoint)*,(global-endpoint)*,(router)*)>

<!--
Whether every configured router will be matched
-->
<!ATTLIST inbound-router matchAll               (true | false)           "false">

<!--
   A message router configures how a resonse message will be routed to a client when
   using request/response message processing.
-->
<!ELEMENT response-router ((endpoint)*,(global-endpoint)*,(router)*)>

<!--
   This attibute defines the response transformers (if any) that will be applied
   to the response message before returning to the client. Developers can define
   a response-router with only a transformer and no actual routers to configure a
   response transformer
-->
<!ATTLIST response-router transformers              IDREFS           #IMPLIED>

<!--
	This attribute can be used to change the default behavior of the respone router
	regarding the processing of the received event. If set to false, the message
	will be router in the outbound router instead of beeing sent back to the
	inbound router.
-->
<!ATTLIST response-router stopProcessing        (true | false)           "true">
	
<!--
A catch-all-strategy is invoked to route an event when an event is not accepted by any of the configured
routers.
-->
<!ELEMENT catch-all-strategy ((endpoint?|global-endpoint?), (properties)?)>

<!--
endpoint
Refers to an optional uri that can be resolvered as a provider.  This attribute functions the same
way as the provider attribute
-->

<!--
className
Is a fully qualified class name of the catch all strategy class
-->
<!ATTLIST catch-all-strategy className                  NMTOKEN           #REQUIRED>

<!--
    A router with route an event based on some criteria configured by the route, this criteria may be based
    on the content of the event, the type of event, metadata, etc.
    It is possible to chain routers together to combine different routing logic to a single
    event.  to chain routers you must define once router inside another.
-->

<!ELEMENT router (endpoint*, global-endpoint*, transaction?, filter?, properties?)>

<!--
    className
    A fully qualified class name of the Router to use.  Implementations must
    use org.mule.umo.routing.UMOOutboundRouter
-->

<!ATTLIST router className                   NMTOKEN           #REQUIRED>

<!--
    filters are used to determine whether the router should accept the current
    message.
    Note that any properties on the filter can be set by setting attributes
    on the filter element. The properties names are the bean properties names
    without the  'set'.
    You can also define two filters on a filter, the left filter and right filter
    these can be used when using logic filters to join filters.
-->

<!ELEMENT filter (filter?, left-filter?, right-filter?)>

<!--
    className
    A fully qualified class name of the Filter to use.  Implementations must
    use org.mule.umo.UMOFilter.
-->

<!ATTLIST filter className                   NMTOKEN           #REQUIRED>

<!-- 
because I can't find a way of allowing arbitary attributes on an element, 
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser
-->
<!ATTLIST filter pattern                   CDATA           #IMPLIED>
<!ATTLIST filter expression                CDATA           #IMPLIED>
<!ATTLIST filter configFile                CDATA           #IMPLIED>
<!ATTLIST filter expectedType              CDATA           #IMPLIED>
<!ATTLIST filter path                      CDATA           #IMPLIED>

<!-- see explanation for 'filter' element -->
<!ELEMENT left-filter (filter?, left-filter?, right-filter?)>

<!-- see explanation for 'filter' element -->
<!ATTLIST left-filter className                   NMTOKEN           #REQUIRED>
<!--
because I can't find a way of allowing arbitary attributes on an element, 
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser
-->
<!ATTLIST left-filter pattern                   CDATA           #IMPLIED>
<!ATTLIST left-filter configFile                CDATA           #IMPLIED>
<!ATTLIST left-filter expectedType              CDATA           #IMPLIED>
<!ATTLIST left-filter path                      CDATA           #IMPLIED>

<!-- see explanation for 'filter' element -->
<!ELEMENT right-filter (filter?, left-filter?, right-filter?)>

<!-- see explanation for 'filter' element -->
<!ATTLIST right-filter className                   NMTOKEN           #REQUIRED>
<!--
because I can't find a way of allowing arbitary attributes on an element, 
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser
-->
<!ATTLIST right-filter pattern                   CDATA           #IMPLIED>
<!ATTLIST right-filter configFile                CDATA           #IMPLIED>
<!ATTLIST right-filter expectedType              CDATA           #IMPLIED>
<!ATTLIST right-filter path                      CDATA           #IMPLIED>

<!--
  Interceptors can be executed in sequence before and/or after the Mule component.
  -->
  
<!ELEMENT interceptor (properties?)>

<!--
	The fully qualified class name of the interceptor to use. This must implement
  	<i>org.mule.UMOInterceptor</i>.

-->
<!ATTLIST interceptor className 			NMTOKEN 		#REQUIRED>

<!--
  An exception strategy overrides the default exceptionStrategy in order to control the
  exception handling beaviour in the system. The class specified must implement
  <i>org.mule.exception.ExceptionStrategy</i>.
  -->
  
<!ELEMENT exception-strategy ((endpoint?|global-endpoint?), (properties)?)>

<!--
	An endpoint to dispatch ExceptionMessages (including the Message being processed)
-->

<!--
	The fully qualified class name of the exception handler to use. This must implement
  	org.mule.exception.ExceptionHandler.

-->
<!ATTLIST exception-strategy className 			NMTOKEN 		#REQUIRED>

<!--
  		A collection of properties for the parent component
-->

<!ELEMENT properties ((property | factory-property | container-property | system-property | map | list)*)>

<!--
  		An property element allows arbitrary name/value pairs.
-->

<!ELEMENT property EMPTY>

<!--
	The name identifies the name of the attribute.
-->

<!ATTLIST property name 			CDATA		#REQUIRED>
<!--
	The value identifies the value of the attribute.
-->
<!ATTLIST property value 			CDATA		#REQUIRED>

<!--
  		An property element allows for an object to be constructed based on the fully
        qualified classname in the factory attribute.
        Note that if the class specified extends <i>org.mule.config.PropertyFactory</a> the factory
        will be used to create the object.
-->

<!ELEMENT factory-property EMPTY>

<!--
	The name identifies the name of the attribute.
-->

<!ATTLIST factory-property name 			CDATA		#REQUIRED>
<!--
	A fully qualified classname of the factory to use.
-->
<!ATTLIST factory-property factory 			CDATA		#REQUIRED>

<!--
  	A property element allows properties to be set from from an IoC contianer
    configured on the Model
-->

<!ELEMENT container-property EMPTY>

<!--
	The name identifies the name of the attribute on the current object
-->

<!ATTLIST container-property name 			CDATA		#REQUIRED>
<!--
	The key identifier for the object to use in the container
-->
<!ATTLIST container-property reference 			CDATA		#REQUIRED>

<!--
	Whether an exception should be thrown if the component is not in the container.
    the default is true
-->
<!ATTLIST container-property required 			(true | false)		"true">
<!--
  	A property element allows properties to be set from the System properties
-->

<!ELEMENT system-property EMPTY>

<!--
	The name identifies the name of the attribute on the object being configured
-->

<!ATTLIST system-property name 			CDATA		#REQUIRED>

<!--
The system property key to use when lookin up the property
-->
<!ATTLIST system-property key 			CDATA		#REQUIRED>
<!--
	The default value will be used of the system property is not set.
-->
<!ATTLIST system-property defaultValue 			CDATA		#IMPLIED>
<!--
	Defines a set of properties for a map property	
-->
<!ELEMENT map ((property | factory-property | container-property | system-property | map | list)*)>

<!-- 
	the name of the map property
-->
<!ATTLIST map name					NMTOKEN		#REQUIRED>

<!--
	Defines a list of properties for a list property	
-->
<!ELEMENT list ((entry | factory-entry | system-entry | container-entry)*)>

<!-- 
	the name of the list property
-->
<!ATTLIST list name					NMTOKEN		#REQUIRED>

<!--
	Defines an entry for a list or array property	
-->
<!ELEMENT entry EMPTY>

<!-- 
	the value of the entry
-->
<!ATTLIST entry value					CDATA		#REQUIRED>

<!--
	Defines an factory entry for a list or array property
-->
<!ELEMENT factory-entry EMPTY>

<!--
	the factory class to use to create the entry
-->
<!ATTLIST factory-entry	factory				NMTOKEN		#REQUIRED>

<!--
	Defines an entry for a list or array property where the value is obtained
    from a container such as Spring
-->
<!ELEMENT container-entry EMPTY>

<!--
	the reference of the object in the container
-->
<!ATTLIST container-entry reference					NMTOKEN		#REQUIRED>

<!--
	determines if the object must be present in the container for configuration to
    succeed
-->
<!ATTLIST container-entry required					(true | false)		"true">
<!--
	Defines an entry for a list or array property
-->
<!ELEMENT system-entry EMPTY>

<!--
	the key of the system property
-->
<!ATTLIST system-entry key					    CDATA		#REQUIRED>

<!--
	a default value if the property is not found
-->
<!ATTLIST system-entry defaultValue			CDATA		#IMPLIED>
<!--
	Optional description of the enclosing element.
	Used for user documentation of XML bean definition documents.
-->
<!ELEMENT description (#PCDATA)>