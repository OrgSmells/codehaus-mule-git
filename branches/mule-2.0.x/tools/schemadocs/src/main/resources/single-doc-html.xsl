<xsl:stylesheet 
        version="2.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        >

    <!-- $Id$ -->

    <!-- this generates html documentation for a particular, named element
         using the information within a single schema.

         a lot of information is available and comments can be found in
         many related areas of the schema; this tries to give a fairly
         comprehensive summary without too much duplication.

         a lot of things could be improved.  obvious targets include:
         - cross-linking
           (now supported via explicit pages in links.xml)
         - using multiple schema 
           (current work-around is to use normalized schema - see normalize.sh)
           (normalized schema are also now generated by maven - see schemadocs profile)

         some features commented-out to give a "friendlier" interface.
    -->

    <xsl:output method="html"/>

    <!-- this is the element we will generate documentation for -->
    <xsl:param name="elementName"/>
    <!-- set this to get the old table format back -->
    <!-- remove once layout ok -->
    <xsl:param name="doubleLineTable"/>

    <!-- the table of pages for linking -->
    <xsl:key name="item-to-page" match="link" use="item"/>
    <xsl:variable name="items-to-pages" select="document('http://svn.codehaus.org/mule/branches/mule-2.x/tools/schemadocs/src/main/resources/links.xml')/links"/>
    <!-- xsl:variable name="items-to-pages" select="document('links.xml')/links"/ -->

    <xsl:template match="/">
        <html>
            <body>
                <xsl:apply-templates
                        select="//xsd:element[@name=$elementName]" mode="start"/>
            </body>
        </html>
    </xsl:template>
  
    <xsl:template match="xsd:element" mode="start">
        <a>
            <!-- define a tag we can link to -->
            <xsl:attribute name="id">#<xsl:value-of select="@name"/></xsl:attribute>
            <h2>&lt;<xsl:value-of select="@name"/> ...&gt; in 2.x</h2>
        </a>
        <p>
            <em>This documentation is automatically generated from the XML schema.
            We are still extending the documentation and improving the presentation;
            please bear with us.
            To add similar documentation to other pages, examine the source of this
            page and copy the {cache ....} section that contains {xslt ...}.
            Change the "elementName" parameter to select the element you want displayed.</em>
        </p>
        <xsl:apply-templates select="." mode="documentation"/>
        <!--
        <xsl:if test="@type">
            <p>Type: <xsl:value-of select="@type"/></p>
        </xsl:if>
        -->
        <h3>Properties</h3>
        <table class="confluenceTable">
            <xsl:choose>
                <xsl:when test="$doubleLineTable">
                    <tr>
                        <th class="confluenceTh" rowspan="2" style="width:25%">Name</th>
                        <th class="confluenceTh" style="width:25%">Type</th>
                        <th class="confluenceTh" style="width:25%">Required</th>
                        <th class="confluenceTh" style="width:25%">Default</th>
                    </tr>
                    <tr>
                        <th class="confluenceTh" colspan="3">Description</th>
                    </tr>
                </xsl:when>
                <xsl:otherwise>
                    <tr>
                        <th class="confluenceTh" style="width:20%">Name</th>
                        <th class="confluenceTh" style="width:10%">Type</th>
                        <th class="confluenceTh" style="width:10%">Required</th>
                        <th class="confluenceTh" style="width:10%">Default</th>
                        <th class="confluenceTh">Description</th>
                    </tr>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:apply-templates select="." mode="attributes"/>
        </table>
        <h3>Child Elements</h3>
        <table class="confluenceTable">
            <xsl:choose>
                <xsl:when test="$doubleLineTable">
                    <tr>
                        <th class="confluenceTh" rowspan="2" style="width:25%">Name</th>
                        <th class="confluenceTh">Type</th>
                    </tr>
                    <tr>
                        <th class="confluenceTh">Description</th>
                    </tr>
                </xsl:when>
                <xsl:otherwise>
                    <tr>
                        <th class="confluenceTh" style="width:20%">Name</th>
                        <th class="confluenceTh" style="width:10%">Type</th>
                        <th class="confluenceTh">Description</th>
                    </tr>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="element-children"/>
            <xsl:if test="@type">
                <xsl:variable name="type" select="@type"/>
                <xsl:apply-templates
                        select="/xsd:schema/xsd:complexType[@name=$type]" mode="elements"/>
            </xsl:if>
        </table>
        <!--
        <h3>Substitution</h3>
        <xsl:apply-templates select="." mode="substitution"/>
        <h3>Type Hierarchy</h3>
        <ul>
            <xsl:apply-templates select="." mode="types"/>
        </ul>
        -->
    </xsl:template>


    <!-- documentation

       we need to collect documentation from:
       - the ref
       - the element
       - the type
       we don't use extension or substitution here -->

    <xsl:template match="xsd:element[@ref]" mode="documentation">
        <xsl:if test="xsd:annotation/xsd:documentation/text()">
            <p>
                <xsl:value-of select="xsd:annotation/xsd:documentation/text()"/>
                <xsl:call-template name="attribution">
                    <xsl:with-param name="text">
                        From reference for element <xsl:value-of select="@ref"/>.
                    </xsl:with-param>
                </xsl:call-template>
            </p>
        </xsl:if>
        <xsl:variable name="ref" select="@ref"/>
        <xsl:apply-templates
                select="/xsd:schema/xsd:element[@name=$ref]" mode="documentation"/>
    </xsl:template>

    <xsl:template match="xsd:element[@name]" mode="documentation">
        <xsl:if test="xsd:annotation/xsd:documentation/text()">
            <p>
                <xsl:value-of select="xsd:annotation/xsd:documentation/text()"/>
                <xsl:call-template name="attribution">
                    <xsl:with-param name="text">
                        From declaration of element <xsl:value-of select="@name"/>.
                    </xsl:with-param>
                </xsl:call-template>
            </p>
        </xsl:if>
        <xsl:if test="@type">
            <xsl:variable name="type" select="@type"/>
            <xsl:apply-templates
                    select="xsd:complexType[@name=$type]" mode="documentation"/>
        </xsl:if>
    </xsl:template>

    <xsl:template match="xsd:complexType" mode="documentation">
        <xsl:if test="xsd:annotation/xsd:documentation/text()">
            <p>
                <xsl:value-of select="xsd:annotation/xsd:documentation/text()"/>
                <xsl:call-template name="attribution">
                    <xsl:with-param name="text">
                        <xsl:choose>
                            <xsl:when test="@name">
                                From declaration of type <xsl:value-of select="@name"/>.
                            </xsl:when>
                            <xsl:otherwise>
                                From type declaration.
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:with-param>
                </xsl:call-template>
            </p>
        </xsl:if>
    </xsl:template>


    <!-- attributes -->

    <xsl:template match="xsd:attribute[@name]" mode="attributes">
        <xsl:choose>
            <xsl:when test="$doubleLineTable">
                <tr><xsl:call-template name="attribute-line-1"/></tr>
                <tr><td colspan="3"><xsl:call-template name="attribute-line-2"/></td></tr>
            </xsl:when>
            <xsl:otherwise>
                <tr>
                    <xsl:call-template name="attribute-line-1"/>
                    <td><xsl:call-template name="attribute-line-2"/></td>
                </tr>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="attribute-line-1">
        <td>
            <xsl:attribute name="rowspan">
                <xsl:choose>
                    <xsl:when test="$doubleLineTable">2</xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
            <xsl:value-of select="@name"/>
        </td>
        <td style="text-align: center"><xsl:call-template name="rewrite-type"><xsl:with-param name="type" select="@type"/></xsl:call-template></td>
        <td style="text-align: center">
            <xsl:choose>
                <xsl:when test="$doubleLineTable">
                    <xsl:choose>
                        <xsl:when test="@required">required</xsl:when>
                        <xsl:otherwise>not required</xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="@required">yes</xsl:when>
                        <xsl:otherwise>no</xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </td>
        <td style="text-align: center">
            <xsl:if test="@default"><xsl:value-of select="@default"/></xsl:if>
        </td>
    </xsl:template>

    <xsl:template name="attribute-line-2">
        <xsl:if test="xsd:annotation/xsd:documentation/text()">
            <p>
                <xsl:value-of select="xsd:annotation/xsd:documentation/text()"/>
            </p>
        </xsl:if>
    </xsl:template>

    <xsl:template match="xsd:element" mode="attributes">
        <xsl:call-template name="attribute-children"/>
        <xsl:if test="@ref">
            <xsl:variable name="ref" select="@ref"/>
            <xsl:apply-templates
                    select="/xsd:schema/xsd:element[@name=$ref]" mode="attributes"/>
        </xsl:if>
        <xsl:if test="@type">
            <xsl:variable name="type" select="@type"/>
            <xsl:apply-templates
                    select="/xsd:schema/xsd:complexType[@name=$type]" mode="attributes"/>
        </xsl:if>
    </xsl:template>

    <xsl:template name="attribute-children">
        <xsl:apply-templates select="xsd:attribute" mode="attributes"/>
        <xsl:apply-templates select="xsd:attributeGroup" mode="attributes"/>
        <xsl:apply-templates select="xsd:sequence" mode="attributes"/>
        <xsl:apply-templates select="xsd:choice" mode="attributes"/>
        <xsl:apply-templates select="xsd:complexType" mode="attributes"/>
        <xsl:apply-templates select="xsd:complexContent" mode="attributes"/>
        <xsl:apply-templates select="xsd:extension" mode="attributes"/>
    </xsl:template>

    <xsl:template match="xsd:attributeGroup" mode="attributes">
        <xsl:if test="@ref">
            <xsl:variable name="ref" select="@ref"/>
            <xsl:apply-templates
                    select="/xsd:schema/xsd:attributeGroup[@name=$ref]" mode="attributes"/>
        </xsl:if>
        <xsl:call-template name="attribute-children"/>
    </xsl:template>

    <xsl:template match="xsd:sequence" mode="attributes">
        <xsl:call-template name="attribute-children"/>
    </xsl:template>

    <xsl:template match="xsd:choice" mode="attributes">
        <xsl:call-template name="attribute-children"/>
    </xsl:template>

    <xsl:template match="xsd:complexType" mode="attributes">
        <xsl:call-template name="attribute-children"/>
    </xsl:template>

    <xsl:template match="xsd:complexContent" mode="attributes">
        <xsl:call-template name="attribute-children"/>
    </xsl:template>

    <xsl:template match="xsd:extension" mode="attributes">
        <xsl:variable name="base" select="@base"/>
        <xsl:apply-templates
                select="/xsd:schema/xsd:complexType[@name=$base]" mode="attributes"/>
        <xsl:call-template name="attribute-children"/>
    </xsl:template>

  
    <!-- child elements -->
    <!-- documentation here more restricted than "documentation" mode -->

    <xsl:template match="xsd:element[@ref]" mode="elements">
        <xsl:choose>
            <xsl:when test="$doubleLineTable">
                <tr><xsl:call-template name="element-line-1"/></tr>
                <tr><xsl:call-template name="element-line-2"/></tr>
            </xsl:when>
            <xsl:otherwise>
                <tr>
                    <xsl:call-template name="element-line-1"/>
                    <xsl:call-template name="element-line-2"/>
                </tr>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="element-line-1">
        <xsl:variable name="ref" select="@ref"/>
        <td>
            <xsl:attribute name="rowspan">
                <xsl:choose>
                    <xsl:when test="$doubleLineTable">2</xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
            <xsl:call-template name="link">
                <xsl:with-param name="item">
                    <xsl:value-of select="@ref"/>
                </xsl:with-param>
            </xsl:call-template>
        </td>
        <xsl:apply-templates
                select="/xsd:schema/xsd:element[@name=$ref]" mode="elements-type"/>
    </xsl:template>

    <xsl:template name="element-line-2">
        <xsl:variable name="ref" select="@ref"/>
        <td>
            <!-- include both ref and element doc -->
            <xsl:apply-templates select="." mode="elements-doc"/>
            <xsl:apply-templates
                    select="/xsd:schema/xsd:element[@name=$ref]" mode="elements-doc"/>
            <xsl:apply-templates
                    select="/xsd:schema/xsd:element[@name=$ref]" mode="elements-abstract"/>
        </td>
    </xsl:template>

    <xsl:template match="xsd:element[@name]" mode="elements">
        <tr>
            <td rowspan="2">
                <xsl:call-template name="link">
                    <xsl:with-param name="item">
                        <xsl:value-of select="@name"/>
                    </xsl:with-param>
                </xsl:call-template>
            </td>
            <xsl:apply-templates select="." mode="elements-type"/>
        </tr>
        <tr><td>
            <xsl:apply-templates select="." mode="elements-doc"/>
            <xsl:apply-templates select="." mode="elements-abstract"/>
        </td></tr>
    </xsl:template>

    <xsl:template match="xsd:element[contains(@name, ':abstract-')]"
                  mode="elements-abstract">
        <xsl:variable name="name" select="@name"/>
        <p>
            <xsl:choose>
                <!-- this should always be true when using the normalized schema -->
                <xsl:when test="/xsd:schema/xsd:element[@substitutionGroup=$name]">
                    This is an abstract element; another element with a compatible
                    type must be used in its place:
                    <ul>
                        <xsl:apply-templates
                                select="/xsd:schema/xsd:element[@substitutionGroup=$name]"
                                mode="elements-list"/>
                    </ul>
                </xsl:when>
                <xsl:otherwise>
                    This is an abstract element; another element with a compatible
                    type must be used in its place.  However, no replacements were
                    found when generating this documentation.
                </xsl:otherwise>
            </xsl:choose>
        </p>
    </xsl:template>

    <xsl:template match="xsd:element[@name]" mode="elements-type">
        <td><xsl:value-of select="@type"/></td>
    </xsl:template>

    <xsl:template match="xsd:element[@name]" mode="elements-list">
        <li>&lt;<xsl:value-of select="@name"/> ...&gt;</li>
    </xsl:template>

    <xsl:template match="xsd:element" mode="elements-doc">
        <xsl:if test="xsd:annotation/xsd:documentation/text()">
            <p>
                <xsl:value-of select="xsd:annotation/xsd:documentation/text()"/>
            </p>
        </xsl:if>
    </xsl:template>

    <xsl:template name="element-children">
        <xsl:apply-templates select="xsd:element" mode="elements"/>
        <xsl:apply-templates select="xsd:group" mode="elements"/>
        <xsl:apply-templates select="xsd:sequence" mode="elements"/>
        <xsl:apply-templates select="xsd:choice" mode="elements"/>
        <xsl:apply-templates select="xsd:complexType" mode="elements"/>
        <xsl:apply-templates select="xsd:complexContent" mode="elements"/>
        <xsl:apply-templates select="xsd:extension" mode="elements"/>
    </xsl:template>

    <xsl:template match="xsd:group" mode="elements">
        <xsl:if test="@ref">
            <xsl:variable name="ref" select="@ref"/>
            <xsl:apply-templates
                    select="/xsd:schema/xsd:group[@name=$ref]" mode="elements"/>
        </xsl:if>
        <xsl:call-template name="element-children"/>
    </xsl:template>

    <xsl:template match="xsd:sequence" mode="elements">
        <xsl:call-template name="element-children"/>
    </xsl:template>

    <xsl:template match="xsd:choice" mode="elements">
        <xsl:call-template name="element-children"/>
    </xsl:template>

    <xsl:template match="xsd:complexType" mode="elements">
        <xsl:call-template name="element-children"/>
    </xsl:template>

    <xsl:template match="xsd:complexContent" mode="elements">
        <xsl:call-template name="element-children"/>
    </xsl:template>

    <xsl:template match="xsd:extension" mode="elements">
        <xsl:variable name="base" select="@base"/>
        <xsl:apply-templates
                select="/xsd:schema/xsd:complexType[@name=$base]" mode="elements"/>
        <xsl:call-template name="element-children"/>
    </xsl:template>


    <!-- substitution -->

    <xsl:template match="xsd:element[@substitutionGroup]" mode="substitution">
        <xsl:variable name="sub" select="@substitutionGroup"/>
        <p>
            This element can be used as a substitute for
            &lt;<xsl:value-of select="$sub"/> ...&gt;
        </p>
        <xsl:apply-templates
                select="/xsd:schema/xsd:element[@name=$sub]" mode="documentation"/>
    </xsl:template>


    <!-- types -->

    <xsl:template match="xsd:element[@type]" mode="types">
        <xsl:variable name="type" select="@type"/>
        <xsl:choose>
            <xsl:when test="/xsd:schema/xsd:complexType[@name=$type]">
                <xsl:apply-templates
                        select="/xsd:schema/xsd:complexType[@name=$type]" mode="types"/>
            </xsl:when>
            <xsl:otherwise>
                <li><xsl:value-of select="@type"/>
                    (This type is not defined in this schema.  This means that
                    other attributes and elements may exist which are not documented
                    here)</li>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
      
    <xsl:template match="xsd:element[./xsd:complexType]" mode="types">
        <xsl:apply-templates select="xsd:complexType"/>
    </xsl:template>
      
    <xsl:template name="type-children">
        <xsl:apply-templates select="xsd:complexType" mode="types"/>
        <xsl:apply-templates select="xsd:complexContent" mode="types"/>
        <xsl:apply-templates select="xsd:extension" mode="types"/>
    </xsl:template>

    <xsl:template match="xsd:complexType" mode="types">
        <li><xsl:value-of select="@name"/></li>
        <xsl:call-template name="type-children"/>
    </xsl:template>

    <xsl:template match="xsd:complexContent" mode="types">
        <xsl:call-template name="type-children"/>
    </xsl:template>

    <xsl:template match="xsd:extension" mode="types">
        <xsl:variable name="base" select="@base"/>
        <xsl:apply-templates
                select="/xsd:schema/xsd:complexType[@name=$base]" mode="types"/>
    </xsl:template>


    <!-- convert common types to nicer text -->

    <xsl:template name="rewrite-type">
        <xsl:param name="type"/>
        <xsl:choose>
            <xsl:when test="$type='mule:substitutableInt'">integer</xsl:when>
            <xsl:when test="$type='mule:substitutableBoolean'">boolean</xsl:when>
            <xsl:when test="$type='mule:substitutableLong'">long</xsl:when>
            <xsl:when test="$type='mule:substitutablePortNumber'">port number</xsl:when>
            <xsl:when test="$type='mule:substitutableClass'">class name</xsl:when>
            <xsl:when test="starts-with($type, 'xsd:')"><xsl:value-of select="substring($type, 5)"/></xsl:when>
            <xsl:otherwise><xsl:value-of select="$type"/></xsl:otherwise>
        </xsl:choose>
    </xsl:template>


    <!-- add attribution -->
  
    <xsl:template name="attribution">
        <xsl:param name="text"/>
        <!-- <br/><small><em><xsl:value-of select="$text"/></em></small> -->
    </xsl:template>


    <!-- links via a separate index - see links.xml -->

    <xsl:template name="link">
        <xsl:param name="item"/>
        <xsl:variable name="page">
            <xsl:apply-templates select="$items-to-pages">
                <xsl:with-param name="item" select="$item"/>
            </xsl:apply-templates>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="string-length($page) > 0">
                <a>
                    <xsl:attribute name="href">
                        <xsl:value-of select="$page"/>#<xsl:value-of select="$item"/>
                    </xsl:attribute>
                    <xsl:value-of select="$item"/>
                </a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$item"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template match="links">
        <xsl:param name="item"/>
        <xsl:value-of select="key('item-to-page', $item)/page"/>
    </xsl:template>

</xsl:stylesheet>
